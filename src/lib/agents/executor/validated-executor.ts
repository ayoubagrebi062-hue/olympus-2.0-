/**
 * VALIDATED EXECUTOR
 *
 * Wraps the AgentExecutor to provide Zod schema validation
 * for agent outputs. This ensures type safety and structured
 * outputs from all 40 agents.
 *
 * Note: This validates the *content* generated by agents,
 * which is separate from the AgentOutput wrapper type.
 *
 * Days 6-7 of OLYMPUS World-Class Refactor
 */

import { z } from 'zod';
import { ExecutionResult } from './types';
import { getAgentSchema } from '../schemas';
import { safeJsonParse } from '../../utils/safe-json';

// ============================================================================
// VALIDATION ERROR
// ============================================================================

export class ValidationError extends Error {
  constructor(
    public readonly agentId: string,
    public readonly issues: z.ZodIssue[],
    public readonly rawOutput: unknown
  ) {
    const issueMessages = issues.map(i => `${i.path.join('.')}: ${i.message}`).join(', ');
    super(`Agent ${agentId} output validation failed: ${issueMessages}`);
    this.name = 'ValidationError';
  }

  /**
   * Get a structured summary of validation issues
   */
  getSummary(): { path: string; message: string; code: string }[] {
    return this.issues.map(issue => ({
      path: issue.path.join('.'),
      message: issue.message,
      code: issue.code,
    }));
  }
}

// ============================================================================
// VALIDATION OPTIONS
// ============================================================================

export interface ValidationOptions {
  /** Throw on validation failure (default: true) */
  throwOnFailure?: boolean;
  /** Attempt to auto-fix common issues (default: true) */
  autoFix?: boolean;
  /** Strip unknown properties (default: false) */
  stripUnknown?: boolean;
  /** Log validation details (default: false) */
  verbose?: boolean;
}

// ============================================================================
// VALIDATED EXECUTION RESULT
// ============================================================================

export interface ValidatedExecutionResult<T> extends ExecutionResult {
  /** The validated and typed output content */
  validatedContent: T;
  /** Whether validation was successful */
  validationSuccess: boolean;
  /** Any validation warnings (non-fatal) */
  validationWarnings: string[];
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Extract JSON from markdown code blocks or raw strings
 */
export function extractJsonFromOutput(output: string): unknown {
  // Try to extract from markdown code block
  const jsonBlockMatch = output.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonBlockMatch) {
    const parsed = safeJsonParse(
      jsonBlockMatch[1].trim(),
      null,
      'extractJsonFromOutput: markdown block'
    );
    if (parsed !== null) return parsed;
  }

  // Try to parse as raw JSON
  const parsed = safeJsonParse(output, null, 'extractJsonFromOutput: raw JSON');
  if (parsed !== null) return parsed;

  // Try to find JSON object in the string
  const jsonObjectMatch = output.match(/\{[\s\S]*\}/);
  if (jsonObjectMatch) {
    const parsed = safeJsonParse(
      jsonObjectMatch[0],
      null,
      'extractJsonFromOutput: JSON object match'
    );
    if (parsed !== null) return parsed;
  }

  // Return original if no JSON found
  return output;
}

/**
 * Apply auto-fixes for common validation issues
 */
export function applyAutoFixes(
  output: Record<string, unknown>,
  agentId: string
): Record<string, unknown> {
  const fixed = { ...output };

  // Add missing constraints array
  if (!fixed.constraints) {
    fixed.constraints = [`Auto-generated constraint for ${agentId}`];
  }

  // Add missing rationale
  if (!fixed.rationale || (typeof fixed.rationale === 'string' && fixed.rationale.length < 50)) {
    fixed.rationale = `This output was generated by the ${agentId} agent. ` +
      'The agent analyzed the input requirements and produced a structured output ' +
      'following the established patterns and best practices for this phase.';
  }

  return fixed;
}

/**
 * Validate output against agent schema without execution
 */
export function validateAgentOutput<T>(
  agentId: string,
  output: unknown
): { success: true; data: T } | { success: false; errors: z.ZodIssue[] } {
  const schema = getAgentSchema(agentId);

  if (!schema) {
    // No schema = always valid
    return { success: true, data: output as T };
  }

  const result = schema.safeParse(output);

  if (result.success) {
    return { success: true, data: result.data as T };
  }

  return { success: false, errors: result.error.issues };
}

/**
 * Validate content from an execution result
 */
export function validateExecutionContent<T>(
  agentId: string,
  result: ExecutionResult,
  options: ValidationOptions = {}
): ValidatedExecutionResult<T> {
  const {
    autoFix = true,
    throwOnFailure = false,
    verbose = false,
  } = options;

  const warnings: string[] = [];

  // Get schema for this agent
  const schema = getAgentSchema(agentId);

  if (!schema) {
    warnings.push(`No schema found for agent ${agentId}, skipping validation`);
    return {
      ...result,
      validatedContent: (result.output ?? {}) as T,
      validationSuccess: true,
      validationWarnings: warnings,
    };
  }

  // Extract content from artifacts if available
  let content: unknown = null;
  if (result.output?.artifacts?.[0]?.content) {
    const artifactContent = result.output.artifacts[0].content;
    content = typeof artifactContent === 'string'
      ? extractJsonFromOutput(artifactContent)
      : artifactContent;
  } else if (result.output) {
    // Try to use output directly
    content = result.output;
  }

  if (verbose) {
    console.log(`[ValidatedExecutor] Agent: ${agentId}`);
    console.log(`[ValidatedExecutor] Content type: ${typeof content}`);
  }

  // Auto-fix if enabled
  if (autoFix && typeof content === 'object' && content !== null) {
    content = applyAutoFixes(content as Record<string, unknown>, agentId);
  }

  // Validate with Zod
  const parseResult = schema.safeParse(content);

  if (!parseResult.success) {
    if (throwOnFailure) {
      throw new ValidationError(agentId, parseResult.error.issues, content);
    }

    warnings.push(`Validation failed: ${parseResult.error.issues.length} issues`);
    return {
      ...result,
      validatedContent: content as T,
      validationSuccess: false,
      validationWarnings: warnings,
    };
  }

  return {
    ...result,
    validatedContent: parseResult.data as T,
    validationSuccess: true,
    validationWarnings: warnings,
  };
}

/**
 * Create a validated wrapper for an execution result
 */
export function createValidatedResult<T>(
  result: ExecutionResult,
  agentId: string,
  options: ValidationOptions = {}
): ValidatedExecutionResult<T> {
  return validateExecutionContent<T>(agentId, result, options);
}
